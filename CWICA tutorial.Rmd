---
title: "Tutorial for CW_ICA"
author: "Yuyan Yi"
date: "2023-11-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading packages

```{r echo=TRUE}
library(fastICA)
library(steadyICA)
library(JADE)
library(ggpubr)
library(ggplot2)
library(MASS)
```

## define mode and CW_ICA function

In this tutorial, we first define the mode function, proposed CW_ICA method.

The input parameters for CW_ICA function are:

1. Number of repetitions: replicate (numerical value)
2. Mixed signals: X (length of singal by number of mixed signals)
3. Maximum number of ICs: maxic
4. Choice of ICA method: algorithm (fastICA, Infomax, JADE),
5. Generate signal-correlation plot: plt=T The output of the function is the detected optimal number of ICs

```{r pressure, echo=TRUE}

mode <- function(x) {
  u <- unique(x)
  tab <- tabulate(match(x, u))
  u[tab == max(tab)]
}


CWICA<-function(replicate,X,maxic,algorithm,plt=F){
  cw<-matrix(0,nrow=replicate,ncol=min(maxic,ncol(X)/2))
  for (rep in 1:replicate) {
    set.seed(rep)
    smp<-sample(c(1:ncol(X)),size = ncol(X)/2)
    grp1<-X[,smp]
    grp2<-X[,-smp]
    for (nic in 2:maxic) {
      if(algorithm == "fastICA"){
        grp1.s <- fastICA(grp1, nic, alg.typ = "deflation", fun = "logcosh", alpha = 1,
                          method = "C", row.norm = FALSE, maxit = 500,
                          tol = 1e-06, verbose = TRUE)$S
        grp2.s <- fastICA(grp2, nic, alg.typ = "deflation", fun = "logcosh", alpha = 1,
                          method = "C", row.norm = FALSE, maxit = 500,
                          tol = 1e-06, verbose = TRUE)$S
      }
      else if(algorithm == "Infomax"){
        grp1.s <- infomaxICA(grp1, nic, whiten =TRUE, maxit=500, eps=1e-06)$S
        grp2.s <- infomaxICA(grp2, nic, whiten =TRUE, maxit=500, eps=1e-06)$S
      }
      else if(algorithm == "JADE"){
        grp1.s <- JADE(grp1, nic, maxit=10000, eps=1e-04)$S
        grp2.s <- JADE(grp2, nic, maxit=10000, eps=1e-04)$S
      }
      cw[rep,nic] <- min(apply(as.matrix(abs(cor(cbind(grp1.s,grp2.s),method="spearman")[1:nic,(nic+1):(2*nic)])),2,max))
    }
  }
  cw<-cw[,-1]
  diff<-matrix(0,nrow = replicate,ncol=8)
  for (col in 1:8) {
    diff[,col]<-cw[,(col+1)]-cw[,col]
  }
  vote = mode(apply( diff, 1, which.min))+1
  
  if(plt == T){
    #pdf(file = paste0(algorithm,"_CWICA.pdf"),height = 8,width = 8)
    par(mfrow=c(1,1))
    plot(x=c(2:ncol(cw)),y=cw[1,2:ncol(cw)],type="l",col=1,ylim=c(0,1),xlab="number of ICs",ylab="correlation",main=paste0(algorithm,"_spearman"))
    for (i in 2:replicate) {
      lines(x=c(2:ncol(cw)),y=cw[i,2:ncol(cw)],type="l",col=i)
    }
    #dev.off()
  }
  return(vote)
}
```

## Generate simulation dataset


```{r echo=TRUE}
set.seed(1)
method=c("fastICA","Infomax")
#parameter
n=512
t = seq(0,5,length.out=n)
q=8
p=30
sd=1

#Brain signal 1 15Hz
hz=15
s1=4*sin(2*pi*t*hz)
s1=s1+rnorm(t,0,1)
#plot(s1,type="l")

#Brain signal 2 7Hz
hz=7
s2=4*sin(2*pi*t*hz)
s2=s2+rnorm(t,0,sd)
#plot(s2,type="l")

#Brain signal 3 10Hz
hz=10
s3=-4*cos(2*pi*t*hz)
s3=s3+rnorm(n,0,sd)
#plot(s3,type="l")

#Eye Component 4Hz with blink
hz=4
s4=-cos(2*pi*t*hz)
s4=s4+rnorm(n,0,sd)
x=seq(0,pi/4,length.out=6)
blink = c(rep(0,54),20 * sin(x*4),rep(0,104),20 * sin(x*4),rep(0,90),20 * sin(x*4),rep(0,154),20 * sin(x*4),rep(0,86))
s4 = blink+s4
#plot(s4,type="l")

#Heart Component 1Hz with heartbeat
hz=1
s5=0.5*sin(2*pi*t*hz)
s5=s5+rnorm(t,0,sd)
beat=c(rep(c(rep(0,20),seq(0,-1,length.out=5),seq(-1,10,length.out=10),seq(10,-0.5,length.out=10),rep(0,25)),7),rep(0,22))
s5=s5+beat
#plot(x=t,y=s5,type="l")

#Line Noise 60Hz
hz=60
s6=5*sin(2*pi*t*hz)
s6=s6+rnorm(t,0,sd)
#plot(s6,type="l")

#Channel Noise 
s7=c(rep(0,350),c(50,200,-100,80,-300,2,-20,0),rep(0,154))
s7=s7+2*rnorm(t,0,sd)
#plot(s7,type="l")

#Muscle Component 60Hz
hz=800
s8=c(rep(0,100),80*(sin((1:50)*800)/(pi*(1:50))),rep(0,150),30*(sin(c(1:40)*300)/(pi*c(1:40))),rep(0,52),40*(sin(c(1:80)*450)/(pi*c(1:80))),rep(0,40))+rnorm(t,0,sd)/10
#plot(s8,type="l")

S=cbind(s1,s2,s3,s4,s5,s6,s7,s8)
plot.ts(S,nc=1,main="Simulated EEG signals")

set.seed(1)
A<-matrix(rnorm(p*q,0,1),q,p)
#Mix six signals with the Mixing Matrix(A):
X<-S %*% A
plot.ts(X[,1:5],nc=1,main="Example of simulated mixed EEG signals")
```


## Coef comparison

In coef comparison, we employ both CW_ICA and ICA-by-block coupled with Pearson and Spearman correlation to determine the optimal number of IC. In this tutorial, we display the result generated by proposed CW_ICA (with Spearman) and ICAbyBlock (with Pearson) methods. For other combination cases, results can be obtained by replacing some parameter with similar code.

### 1. CW_ICA + Spearman + FastICA

```{r echo=TRUE}
maxic = 15
CWICA_result = CWICA(10,X,maxic,"fastICA",plt=T)
print(paste0("The estimated number of ICs obtained by CW_ICA + Spearman + FastICA is ",CWICA_result))

```

### 2. ICAbyBlock + Pearson + FastICA
```{r echo=TRUE}

maxic=15
###ICAbyBlock+Pearson###
icabyblock<-matrix(NA,nrow=maxic,ncol=min(maxic,ncol(X)/2))
set.seed(1)
smp<-sample(c(1:ncol(X)),size = ncol(X)/2)
grp1<-X[,smp]
grp2<-X[,-smp]
for (nic in 2:maxic) {
  grp1.s <- fastICA(grp1, nic, alg.typ = "deflation", fun = "logcosh", alpha = 1,method = "C", row.norm = FALSE, maxit = 500,tol = 1e-06, verbose = TRUE)$S
  grp2.s <- fastICA(grp2, nic, alg.typ = "deflation", fun = "logcosh", alpha = 1,method = "C", row.norm = FALSE, maxit = 500,tol = 1e-06, verbose = TRUE)$S
  #grp1.s <- infomaxICA(grp1, nic, whiten =TRUE, maxit=500, eps=1e-06)$S
  #grp2.s <- infomaxICA(grp2, nic, whiten =TRUE, maxit=500, eps=1e-06)$S
  corr = sort(abs(as.vector(cor(cbind(grp1.s,grp2.s),method="pearson"))),decreasing = T)
  icabyblock[nic,(1:nic)] <- corr[seq((nic*2+2),(nic*2+nic*(2^2-2)),by = 2)]
}
par(mfrow=c(1,1))
plot(x=c(2:ncol(icabyblock)),y=icabyblock[1,2:ncol(icabyblock)],lwd = 3,type="l",col=1,ylim=c(0,1),xlab="number of ICs",ylab="correlation",main=paste0("ICAbyBlocks_Pearson_FastICA"))
for (i in 2:maxic) {
  lines(x=c(2:ncol(icabyblock)),y=icabyblock[i,2:ncol(icabyblock)],lwd = 3,type="l",col=i)
}
```


## Accuracy test

In accuracy test, we repeatedly and randomly generate the mixing matrix while keeping the original source signal unchanged, to generate multiple mixed-signal datasets.

The result obtained by proposed CW_ICA can be reproduced by code as below:

```{r echo=TRUE}

replicate<-c(5,10,25)
result<-NULL
Accu = rep(0,length(replicate))
for (i in 1:length(replicate)) {
  accu<-rep(0,replicate[i])
  for (j in 1:length(method)) {
    for (rep in 1:replicate[i]) {
      set.seed(rep)
      A<-matrix(rnorm(p*q,0,1),q,p)
      X<-S %*% A
      accu[rep]<-CWICA(10,X,15,"fastICA",plt=F)
    }
  }
  Accu[i]=length(accu==q)/length(accu)
}

print(paste0("The true number of ICs is ", q))
for (i in 1:length(replicate)) {
  print(paste0("When number of dataset = ", replicate[i],", the accuracy of CW_ICA is ",Accu[i]))
}

```


## Robustness test

In the robustness test, we simulate datasets with different properties by changing the parameter setting of simulated source signals and mixing matrix.

1. number of mixed signals
2. signal-to-noise ratio
3. length of signal
4. range of frequency

In this tutorial, we provide the setting of case with changing length of signal, other cases can be generated with similar way. 

```{r echo=TRUE}

#####Simulated Data Generation####

#Compare n (signal length)

q=5  
p=100
n=1024
sd=0.1
hz=c(5,10,20,40,70)
#source 5Hz, 10Hz,20Hz,40Hz,70Hz,WN(sd=0.1)
set.seed(1)
wn=rnorm(n,0,sd)
s1=2*sin(pi/hz[1]*c(1:n))+wn
s2=2*cos(pi/hz[2]*c(1:n))+wn
s3=cos(pi/hz[3]*c(1:n))+wn
s4=3*sin(pi/hz[4]*c(1:n))+wn
s5=-sin(pi/hz[5]*c(1:n))+wn

S=cbind(s1,s2,s3,s4,s5)
plot.ts(S,nc=1,main="Sim for time length")
#Mixing matrix A
set.seed(1)
A<-matrix(rnorm(p*q,0,1),q,p)
#Mix two signals with the Mixing Matrix(A):
X<-S %*% A

```

```{r echo=TRUE}
#Compare n (signal length)
sig.length = c(64,128,256,512,1024,2048)
q=5  
p=100
sd=0.1
hz=c(5,10,20,40,70)
#source 5Hz, 10Hz,20Hz,40Hz,70Hz,WN(sd=0.1)
result = rep(0,length(sig.length))
for (i in 1:length(sig.length)) {
  n = sig.length[i]
  set.seed(1)
  wn=rnorm(n,0,sd)
  s1=2*sin(pi/hz[1]*c(1:n))+wn
  s2=2*cos(pi/hz[2]*c(1:n))+wn
  s3=cos(pi/hz[3]*c(1:n))+wn
  s4=3*sin(pi/hz[4]*c(1:n))+wn
  s5=-sin(pi/hz[5]*c(1:n))+wn
  S=cbind(s1,s2,s3,s4,s5)
  #Mixing matrix A
  set.seed(1)
  A<-matrix(rnorm(p*q,0,1),q,p)
  #Mix two signals with the Mixing Matrix(A):
  X<-S %*% A
  maxic = 15
  CWICA_result = CWICA(10,X,maxic,"fastICA",plt=F)
  result[i] = CWICA_result
}

print(paste0("The true number of ICs is ", q))
for (i in 1:length(sig.length)) {
  print(paste0("When length of signal = ", sig.length[i],", the estimated number of ICs is ",result[i]))
}
```